name: Generate Excel Test Reports

on:
  repository_dispatch:
    types: [generate-excel-report]

jobs:
  generate-excel-report:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
      pull-requests: write
      id-token: write
    
    steps:
    # ================== SETUP M√îI TR∆Ø·ªúNG ==================
    - name: Checkout code
      uses: actions/checkout@v4
      
    # ================== SETUP PYTHON CHO EXCEL ==================
    - name: Setup Python for Excel generation
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
        
    - name: Cache Python dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
        
    - name: Install Python dependencies
      run: |
        # C√†i ƒë·∫∑t th∆∞ vi·ªán Python c·∫ßn thi·∫øt ƒë·ªÉ t·∫°o file Excel
        pip install --no-cache-dir pandas openpyxl xlsxwriter lxml beautifulsoup4
        
    # ================== DOWNLOAD ARTIFACTS T·ª™ WORKFLOW CH√çNH ==================
    - name: Get workflow run ID and download artifacts
      id: get-run
      run: |
        # L·∫•y workflow run ID t·ª´ client payload ho·∫∑c t√¨m workflow g·∫ßn nh·∫•t
        if [ -n "${{ github.event.client_payload.workflow_run_id }}" ]; then
          RUN_ID="${{ github.event.client_payload.workflow_run_id }}"
        else
          # Fallback: t√¨m workflow g·∫ßn nh·∫•t th√†nh c√¥ng
          RUN_ID=$(gh api repos/${{ github.repository }}/actions/runs \
            --jq '.workflow_runs[] | select(.name == "Unit Tests with Excel Report" and .conclusion == "success") | .id' \
            | head -1)
        fi
        echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
        
        # Download artifacts in parallel
        gh run download $RUN_ID --name test-results --dir ./TestResults/ &
        gh run download $RUN_ID --name coverage-report --dir ./coveragereport/ &
        wait
        
    # ================== T·∫†O FILE EXCEL - PH·∫¶N QUAN TR·ªåNG NH·∫§T ==================
    - name: Create Excel coverage report
      run: |
        # T·∫°o file Python script inline ƒë·ªÉ generate Excel report
        cat > generate_excel_report.py << 'EOF'
        import pandas as pd
        import json
        import xml.etree.ElementTree as ET
        from datetime import datetime
        import os
        import glob
        from bs4 import BeautifulSoup
        
        def parse_cobertura_xml():
            """Parse file XML coverage ƒë·ªÉ l·∫•y d·ªØ li·ªáu chi ti·∫øt"""
            xml_files = glob.glob('./TestResults/**/coverage.cobertura.xml', recursive=True)
            if not xml_files:
                return None
                
            tree = ET.parse(xml_files[0])
            root = tree.getroot()
            
            # L·∫•y th√¥ng tin t·ªïng quan v·ªÅ coverage
            line_rate = float(root.get('line-rate', 0)) * 100
            branch_rate = float(root.get('branch-rate', 0)) * 100
            
            # L·∫•y chi ti·∫øt coverage theo t·ª´ng class/file - optimized
            classes_data = []
            for package in root.findall('.//package'):
                package_name = package.get('name', 'Unknown')
                
                for cls in package.findall('.//class'):
                    class_name = cls.get('name', 'Unknown')
                    filename = cls.get('filename', 'Unknown')
                    class_line_rate = float(cls.get('line-rate', 0)) * 100
                    class_branch_rate = float(cls.get('branch-rate', 0)) * 100
                    
                    # ƒê·∫øm s·ªë d√≤ng ƒë∆∞·ª£c cover v√† ch∆∞a cover - optimized
                    lines = cls.findall('.//line')
                    total_lines = len(lines)
                    covered_lines = sum(1 for l in lines if l.get('hits', '0') != '0')
                    
                    classes_data.append({
                        'Package': package_name,
                        'Class': class_name,
                        'File': filename,
                        'Line Coverage (%)': round(class_line_rate, 2),
                        'Branch Coverage (%)': round(class_branch_rate, 2),
                        'Total Lines': total_lines,
                        'Covered Lines': covered_lines,
                        'Uncovered Lines': total_lines - covered_lines
                    })
            
            return {
                'summary': {
                    'line_coverage': round(line_rate, 2),
                    'branch_coverage': round(branch_rate, 2)
                },
                'classes': classes_data
            }
        
        def parse_test_results():
            """Parse file TRX ƒë·ªÉ l·∫•y k·∫øt qu·∫£ test chi ti·∫øt"""
            trx_files = glob.glob('./TestResults/**/test-results.trx', recursive=True)
            test_data = []
            
            if trx_files:
                try:
                    with open(trx_files[0], 'r', encoding='utf-8') as f:
                        content = f.read()
                        soup = BeautifulSoup(content, 'xml')
                        
                    # Parse t·ª´ng test result - optimized
                    for result in soup.find_all('UnitTestResult'):
                        test_name = result.get('testName', 'Unknown')
                        outcome = result.get('outcome', 'Unknown')
                        duration = result.get('duration', '00:00:00')
                        
                        # L·∫•y error message n·∫øu test fail - optimized
                        error_message = ""
                        error_info = result.find('ErrorInfo')
                        if error_info:
                            message_elem = error_info.find('Message')
                            if message_elem:
                                error_message = message_elem.get_text()
                        
                        test_data.append({
                            'Test Name': test_name,
                            'Result': outcome,
                            'Duration': duration,
                            'Error Message': error_message
                        })
                except Exception as e:
                    print(f"Error parsing TRX file: {e}")
            
            return test_data
        
        def create_excel_report():
            """üî• H√ÄM CH√çNH T·∫†O FILE EXCEL üî•"""
            
            # Parse d·ªØ li·ªáu t·ª´ c√°c file output
            coverage_data = parse_cobertura_xml()
            test_data = parse_test_results()
            
            # T·∫°o t√™n file Excel v·ªõi timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            excel_file = f'./coveragereport/Coverage_Report_{timestamp}.xlsx'
            
            # üìä T·∫†O FILE EXCEL V·ªöI NHI·ªÄU SHEET
            with pd.ExcelWriter(excel_file, engine='xlsxwriter') as writer:
                workbook = writer.book
                
                # üé® ƒê·ªäNH NGHƒ®A C√ÅC FORMAT CHO EXCEL
                header_format = workbook.add_format({
                    'bold': True,
                    'text_wrap': True,
                    'valign': 'top',
                    'fg_color': '#4472C4',      # M√†u n·ªÅn xanh
                    'font_color': 'white',       # Ch·ªØ m√†u tr·∫Øng
                    'border': 1
                })
                
                cell_format = workbook.add_format({
                    'text_wrap': True,
                    'valign': 'top',
                    'border': 1
                })
                
                percent_format = workbook.add_format({
                    'num_format': '0.00%',
                    'text_wrap': True,
                    'valign': 'top',
                    'border': 1
                })
                
                # üìã SHEET 1: SUMMARY - T·ªïng quan
                summary_data = []
                if coverage_data:
                    summary_data = [
                        ['Metric', 'Value', 'Status'],
                        ['Line Coverage', f"{coverage_data['summary']['line_coverage']}%", 
                         '‚úÖ Pass' if coverage_data['summary']['line_coverage'] >= 70 else '‚ùå Fail'],
                        ['Branch Coverage', f"{coverage_data['summary']['branch_coverage']}%", ''],
                        ['Test Run Date', datetime.now().strftime("%Y-%m-%d %H:%M:%S"), ''],
                        ['Total Test Classes', len(coverage_data['classes']) if coverage_data['classes'] else 0, ''],
                        ['Minimum Threshold', '70%', ''],
                    ]
                else:
                    summary_data = [
                        ['Metric', 'Value', 'Status'],
                        ['Line Coverage', 'N/A', 'No data available'],
                    ]
                
                df_summary = pd.DataFrame(summary_data[1:], columns=summary_data[0])
                df_summary.to_excel(writer, sheet_name='Summary', index=False)
                
                # Format sheet Summary
                worksheet_summary = writer.sheets['Summary']
                worksheet_summary.set_column('A:A', 20)
                worksheet_summary.set_column('B:B', 15)
                worksheet_summary.set_column('C:C', 15)
                
                # √Åp d·ª•ng format cho t·ª´ng cell - optimized
                for col_num, col_name in enumerate(df_summary.columns):
                    worksheet_summary.write(0, col_num, col_name, header_format)
                for row_num in range(len(df_summary)):
                    for col_num in range(len(df_summary.columns)):
                        worksheet_summary.write(row_num + 1, col_num, df_summary.iloc[row_num, col_num], cell_format)
                
                # üìä SHEET 2: COVERAGE DETAILS - Chi ti·∫øt coverage theo class
                if coverage_data and coverage_data['classes']:
                    df_classes = pd.DataFrame(coverage_data['classes'])
                    df_classes.to_excel(writer, sheet_name='Coverage Details', index=False)
                    
                    worksheet_details = writer.sheets['Coverage Details']
                    # Set ƒë·ªô r·ªông c·ªôt
                    worksheet_details.set_column('A:A', 25)  # Package
                    worksheet_details.set_column('B:B', 30)  # Class
                    worksheet_details.set_column('C:C', 40)  # File
                    worksheet_details.set_column('D:D', 18)  # Line Coverage
                    worksheet_details.set_column('E:E', 18)  # Branch Coverage
                    worksheet_details.set_column('F:F', 12)  # Total Lines
                    worksheet_details.set_column('G:G', 15)  # Covered Lines
                    worksheet_details.set_column('H:H', 15)  # Uncovered Lines
                    
                    # √Åp d·ª•ng format - optimized
                    for col_num, col_name in enumerate(df_classes.columns):
                        worksheet_details.write(0, col_num, col_name, header_format)
                    for row_num in range(len(df_classes)):
                        for col_num in range(len(df_classes.columns)):
                            worksheet_details.write(row_num + 1, col_num, df_classes.iloc[row_num, col_num], cell_format)
                
                # üß™ SHEET 3: TEST RESULTS - K·∫øt qu·∫£ test chi ti·∫øt
                if test_data:
                    df_tests = pd.DataFrame(test_data)
                    df_tests.to_excel(writer, sheet_name='Test Results', index=False)
                    
                    worksheet_tests = writer.sheets['Test Results']
                    worksheet_tests.set_column('A:A', 50)  # Test Name
                    worksheet_tests.set_column('B:B', 12)  # Result
                    worksheet_tests.set_column('C:C', 12)  # Duration
                    worksheet_tests.set_column('D:D', 60)  # Error Message
                    
                    # Highlight test failed v·ªõi m√†u ƒë·ªè - optimized
                    fail_format = workbook.add_format({
                        'text_wrap': True,
                        'valign': 'top',
                        'border': 1,
                        'bg_color': '#FFE6E6'  # M√†u ƒë·ªè nh·∫°t
                    })
                    
                    for col_num, col_name in enumerate(df_tests.columns):
                        worksheet_tests.write(0, col_num, col_name, header_format)
                    for row_num in range(len(df_tests)):
                        for col_num in range(len(df_tests.columns)):
                            cell_value = df_tests.iloc[row_num, col_num]
                            # Highlight failed tests v·ªõi background m√†u ƒë·ªè nh·∫°t
                            if col_num == 1 and cell_value == 'Failed':
                                worksheet_tests.write(row_num + 1, col_num, cell_value, fail_format)
                            else:
                                worksheet_tests.write(row_num + 1, col_num, cell_value, cell_format)
                
                # üìà SHEET 4: COVERAGE TRENDS - Xu h∆∞·ªõng coverage (ƒë·ªÉ m·ªü r·ªông sau)
                trends_data = [
                    ['Date', 'Line Coverage (%)', 'Branch Coverage (%)', 'Total Tests'],
                    [datetime.now().strftime("%Y-%m-%d"), 
                     coverage_data['summary']['line_coverage'] if coverage_data else 0,
                     coverage_data['summary']['branch_coverage'] if coverage_data else 0,
                     len(test_data) if test_data else 0]
                ]
                
                df_trends = pd.DataFrame(trends_data[1:], columns=trends_data[0])
                df_trends.to_excel(writer, sheet_name='Coverage Trends', index=False)
                
                worksheet_trends = writer.sheets['Coverage Trends']
                worksheet_trends.set_column('A:A', 15)
                worksheet_trends.set_column('B:B', 18)
                worksheet_trends.set_column('C:C', 18)
                worksheet_trends.set_column('D:D', 15)
                
                # √Åp d·ª•ng format cho trends - optimized
                for col_num, col_name in enumerate(df_trends.columns):
                    worksheet_trends.write(0, col_num, col_name, header_format)
                for row_num in range(len(df_trends)):
                    for col_num in range(len(df_trends.columns)):
                        worksheet_trends.write(row_num + 1, col_num, df_trends.iloc[row_num, col_num], cell_format)
            
            print(f"‚úÖ Excel report generated: {excel_file}")
            return excel_file
        
        # üöÄ CH·∫†Y H√ÄM CH√çNH
        if __name__ == "__main__":
            excel_file = create_excel_report()  # üìä T·∫†O FILE EXCEL
        EOF
        
        # üêç CH·∫†Y PYTHON SCRIPT ƒê·ªÇ T·∫†O EXCEL
        python generate_excel_report.py
        
    # ================== UPLOAD EXCEL FILE ARTIFACT ==================
    - name: Upload Excel coverage report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: coverage-excel-report
        path: ./coveragereport/Coverage_Report_*.xlsx  # üìä Upload ch·ªâ file Excel
        retention-days: 30 