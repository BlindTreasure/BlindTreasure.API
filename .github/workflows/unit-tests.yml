name: Unit Tests with Excel Report (Functions + Statistics + Matrices)

on:
  push:
    branches: [devphuctrann]

jobs:
  test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            nuget-${{ runner.os }}-

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
          cache: true
          cache-dependency-path: '**/*.csproj'

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          pip install pandas openpyxl xlsxwriter lxml beautifulsoup4

      - name: Restore dependencies
        run: dotnet restore BlindTreasure.API.sln

      - name: Build with XML docs
        run: |
          dotnet build BlindTreasure.API.sln \
            --no-restore \
            --configuration Release \
            /p:GenerateDocumentationFile=true
          find ./BlindTreasure.UnitTest/bin -name "*.xml" | sort || true

      - name: Run unit tests with coverage
        run: |
          dotnet test BlindTreasure.API.sln \
            --no-build \
            --configuration Release \
            --verbosity normal \
            --collect:"XPlat Code Coverage" \
            --results-directory ./TestResults/ \
            --logger "trx;LogFileName=test-results.trx"
          find ./TestResults -name "test-results.trx" | sort || true

      - name: Generate Excel Report (Functions + Statistics + Matrices)
        run: |
          mkdir -p coveragereport
          cat > generate_excel_report.py << 'EOF'
          import pandas as pd
          import xml.etree.ElementTree as ET
          from bs4 import BeautifulSoup
          from collections import defaultdict
          import glob, re

          XML_PREFIX = "M:BlindTreasure.UnitTest.Services."

          def sanitize_sheet_name(name: str, existing: set) -> str:
              """Excel chỉ cho tối đa 31 ký tự"""
              base = name[:31]
              final = base
              suffix = 2
              while final in existing:
                  final = f"{base[:28]}_{suffix}"
                  suffix += 1
              existing.add(final)
              return final

          def strip_params(s): return s.split('(')[0] if s else s
          def short_class(fq): return fq.split('.')[-1] if fq else ''
          def norm(s): return re.sub(r'[^A-Za-z0-9_]', '', (s or '')).lower()

          def base_function_from_test(method_name: str) -> str:
              m = strip_params(method_name or '')
              if '_Should' in m: return m.split('_Should',1)[0]
              if '_When'   in m: return m.split('_When',1)[0]
              return m

          def classify_case(name: str) -> str:
              n = (name or '').lower()
              if 'boundary' in n: return 'B'
              if 'abnormal' in n: return 'A'
              if 'normal'   in n: return 'N'
              return 'N'

          def expected_from_name(name: str) -> str:
              n = (name or '').lower()
              if 'shouldreturntrue'  in n or 'should_be_true' in n:  return 'TRUE'
              if 'shouldreturnfalse' in n or 'should_be_false' in n: return 'FALSE'
              return ''

          def to_conditions_from_name(name: str):
              base = strip_params(name or '')
              if '_When' not in base: return []
              cond = base.split('_When',1)[1]
              parts = [p for p in re.split(r'_And_|_', cond) if p]
              out=[]
              for p in parts:
                  s = re.sub(r'([a-z0-9])([A-Z])', r'\1 \2', p).replace('_',' ').strip()
                  out.append(s)
              return out

          def extract_functions():
              xml_files = glob.glob('./BlindTreasure.UnitTest/bin/**/*.xml', recursive=True)
              agg = {}
              for f in xml_files:
                  try: root = ET.parse(f).getroot()
                  except Exception: continue
                  for m in root.findall('.//member'):
                      name = m.get('name','')
                      if not name.startswith(XML_PREFIX): continue
                      parts = name.split('.')
                      if len(parts) < 2: continue
                      cls = parts[-2]
                      test_method = strip_params(parts[-1])
                      func = base_function_from_test(test_method)
                      key=(cls,func)
                      if key not in agg:
                          agg[key]={"Class":cls,"Function":func}
              return list(agg.values())

          def parse_trx():
              trx_files = glob.glob('./TestResults/**/test-results.trx', recursive=True)
              if not trx_files: return []
              with open(trx_files[0],'r',encoding='utf-8') as f:
                  soup = BeautifulSoup(f.read(),'xml')
              id_map={}
              for ut in soup.find_all('UnitTest'):
                  ut_id = ut.get('id') or ut.get('testId')
                  tm = ut.find('TestMethod')
                  if ut_id and tm is not None:
                      class_full = tm.get('className','')
                      method_name = strip_params(tm.get('name',''))
                      id_map[ut_id]=(short_class(class_full), method_name)
              out=[]
              for res in soup.find_all('UnitTestResult'):
                  tid = res.get('testId')
                  if tid and tid in id_map:
                      cls, mth = id_map[tid]
                      out.append({
                          "Class": cls,
                          "Method": mth,
                          "Base": base_function_from_test(mth),
                          "Outcome": res.get('outcome','Unknown'),
                          "Display": strip_params(res.get('testName','')),
                          "ExecutedAt": res.get('endTime') or res.get('startTime') or ''
                      })
              return out

          def build_core():
              funcs = extract_functions()
              trx = parse_trx()
              idx = defaultdict(list)
              for t in trx:
                  idx[(t["Class"], t["Base"])].append(t)

              func_rows=[]
              for i,f in enumerate(funcs,1):
                  func_rows.append({
                      "No": i,
                      "Class Name": f["Class"],
                      "Function Name": f["Function"],
                      "Sheet Name": f["Function"]
                  })

              stat_rows=[]
              for i,f in enumerate(funcs,1):
                  tests = idx.get((f["Class"], f["Function"]), [])
                  p=f_=u=0; N=A=B=0
                  for t in tests:
                      if t["Outcome"]=="Passed": p+=1
                      elif t["Outcome"]=="Failed": f_+=1
                      else: u+=1
                      c = classify_case(t["Display"] or t["Method"])
                      if c=='N': N+=1
                      elif c=='A': A+=1
                      elif c=='B': B+=1
                  stat_rows.append({
                      "No": i,
                      "Function Code": f'=HYPERLINK("#{f["Function"]}!A1","Code")',
                      "Passed": p, "Failed": f_, "Untested": u,
                      "N": N, "A": A, "B": B,
                      "Total Test Cases": p+f_+u
                  })
              return funcs, pd.DataFrame(func_rows), pd.DataFrame(stat_rows), idx

          def write_matrix(workbook, writer, func, tests, existing):
              ws_name = sanitize_sheet_name(func["Function"], existing)
              ws = workbook.add_worksheet(ws_name)
              writer.sheets[ws_name]=ws
              # chỉ ghi placeholder matrix cho ngắn gọn
              ws.write(0,0,"Matrix for "+func["Function"])
              return ws_name

          def main():
              funcs, df_funcs, df_stats, idx = build_core()
              out = "./coveragereport/Functions_Statistics_Report.xlsx"
              existing=set()
              with pd.ExcelWriter(out, engine="xlsxwriter") as w:
                  df_funcs.to_excel(w, sheet_name="Functions", index=False)
                  df_stats.to_excel(w, sheet_name="Statistics", index=False)
                  wb = w.book
                  for f in funcs:
                      tests = idx.get((f["Class"], f["Function"]), [])
                      write_matrix(wb, w, f, tests, existing)
              print(out)

          if __name__=="__main__":
              main()
          EOF
          python generate_excel_report.py

      - name: Upload Excel coverage reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: excel-functions-statistics-report
          path: ./coveragereport/Functions_Statistics_Report.xlsx
          retention-days: 30
