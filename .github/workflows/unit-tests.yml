name: Unit Tests with Excel Report (Functions + Statistics + Matrices)

on:
  push:
    branches: [unit-test]

jobs:
  test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            nuget-${{ runner.os }}-

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
          cache: true
          cache-dependency-path: '**/*.csproj'

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          pip install pandas openpyxl xlsxwriter lxml beautifulsoup4

      - name: Restore dependencies
        run: dotnet restore BlindTreasure.API.sln

      - name: Build with XML docs
        run: |
          dotnet build BlindTreasure.API.sln \
            --no-restore \
            --configuration Release \
            /p:GenerateDocumentationFile=true
          find ./BlindTreasure.UnitTest/bin -name "*.xml" | sort || true

      - name: Run unit tests with coverage
        run: |
          dotnet test BlindTreasure.API.sln \
            --no-build \
            --configuration Release \
            --verbosity normal \
            --collect:"XPlat Code Coverage" \
            --results-directory ./TestResults/ \
            --logger "trx;LogFileName=test-results.trx"
          find ./TestResults -name "test-results.trx" | sort || true

      - name: Generate Excel Report (Functions + Statistics + Matrices)
        run: |
          mkdir -p coveragereport
          cat > generate_excel_report.py << 'EOF'
          import pandas as pd
          import xml.etree.ElementTree as ET
          from bs4 import BeautifulSoup
          from collections import defaultdict
          import glob, re

          XML_PREFIX = "M:BlindTreasure.UnitTest.Services."

          # ---------- helpers ----------
          def strip_params(s): return s.split('(')[0] if s else s
          def short_class(fq): return fq.split('.')[-1] if fq else ''
          def norm(s): return re.sub(r'[^A-Za-z0-9_]', '', (s or '')).lower()

          def base_function_from_test(method_name: str) -> str:
              """Extract function-under-test from test method: RegisterCustomerAsync_Should... -> RegisterCustomerAsync"""
              m = strip_params(method_name or '')
              if '_Should_' in m: return m.split('_Should_',1)[0]
              if '_Should' in m: return m.split('_Should',1)[0]
              if '_When'   in m: return m.split('_When',1)[0]
              return m

          def same_function(doc_func: str, test_method: str) -> bool:
              """Improved matching logic - more flexible"""
              d = norm(doc_func)
              t = norm(base_function_from_test(test_method))
          
              # Exact match
              if d == t:
                  return True
          
              # Handle Async suffix
              if d.endswith('async') and t == d[:-5]:
                  return True
              if t.endswith('async') and d == t[:-5]:
                  return True
          
              # Substring matching for partial names
              if len(d) > 3 and len(t) > 3:
                  if d in t or t in d:
                      return True
          
              return False

          def extract_xml_tag_value(remarks_text: str, tag: str) -> str:
              """Extract value from XML tag in remarks"""
              if not remarks_text:
                  return ''
          
              lines = remarks_text.splitlines()
              for line in lines:
                  line = line.strip()
                  if line.startswith(f'{tag}:'):
                      return line.replace(f'{tag}:', '').strip()
              return ''

          def parse_input_conditions(input_conditions_text: str) -> list:
              """Parse input conditions from XML tag"""
              if not input_conditions_text:
                  return []
          
              # Split by common delimiters
              conditions = []
              for delimiter in [';', ',', '|', '\n']:
                  if delimiter in input_conditions_text:
                      conditions = [c.strip() for c in input_conditions_text.split(delimiter) if c.strip()]
                      break
          
              # If no delimiters found, treat as single condition
              if not conditions and input_conditions_text.strip():
                  conditions = [input_conditions_text.strip()]
          
              return conditions[:4]  # Max 4 conditions

          def get_test_type_from_xml(remarks_text: str) -> str:
              """Get test type from XML remarks"""
              test_type = extract_xml_tag_value(remarks_text, 'TestType')
              if test_type.lower() in ['normal', 'abnormal', 'boundary']:
                  return test_type[0].upper()  # N, A, B
              return 'N'  # Default to Normal

          def get_expected_result_from_xml(remarks_text: str) -> str:
              """Get expected result type from XML"""
              expected_result = extract_xml_tag_value(remarks_text, 'ExpectedResult').lower()
              exception_expected = extract_xml_tag_value(remarks_text, 'ExceptionExpected').lower()
          
              if exception_expected == 'true' or 'exception' in expected_result:
                  return 'EXCEPTION'
              elif 'true' in expected_result or 'success' in expected_result:
                  return 'TRUE'
              elif 'false' in expected_result:
                  return 'FALSE'
              return ''

          def fallback_from_name(name: str) -> dict:
              """Fallback parsing from test method name if XML tags not available"""
              n = (name or '').lower()
          
              # Test type classification
              test_type = 'N'
              if 'boundary' in n: test_type = 'B'
              elif 'abnormal' in n or 'invalid' in n or 'error' in n: test_type = 'A'
          
              # Expected result
              expected_result = ''
              if 'shouldthrow' in n or 'exception' in n: expected_result = 'EXCEPTION'
              elif 'shouldreturn' in n and 'true' in n: expected_result = 'TRUE'
              elif 'shouldreturn' in n and 'false' in n: expected_result = 'FALSE'
              elif 'should' in n and ('create' in n or 'update' in n or 'upload' in n): expected_result = 'TRUE'
          
              # Return value
              return_value = ''
              if 'shouldcreate' in n: return_value = 'Created object'
              elif 'shouldupdate' in n: return_value = 'Updated object'
              elif 'shouldupload' in n: return_value = 'Object with URL'
              elif 'shouldreturn' in n and 'true' in n: return_value = 'true'
              elif 'shouldreturn' in n and 'false' in n: return_value = 'false'
          
              # Log message
              log_message = ''
              if 'conflict' in n or 'exists' in n: log_message = 'Already exists'
              elif 'notfound' in n: log_message = 'Not found'
              elif 'invalid' in n or 'empty' in n: log_message = 'Invalid input'
              elif 'unauthorized' in n: log_message = 'Unauthorized access'
              elif 'forbidden' in n: log_message = 'Forbidden access'
          
              # Input conditions
              conditions = []
              if 'valid' in n and 'data' in n: conditions.append('Valid input data provided')
              if 'exists' in n: conditions.append('Entity exists in system')
              if 'notexists' in n: conditions.append('Entity does not exist')
              if 'empty' in n: conditions.append('Required field is empty')
              if 'invalid' in n: conditions.append('Invalid input provided')
              if not conditions: conditions.append('Standard test condition')
          
              return {
                  'test_type': test_type,
                  'expected_result': expected_result,
                  'return_value': return_value,
                  'log_message': log_message,
                  'conditions': conditions
              }

          def safe_sheet_name(name, existing_sheets):
              """Create a safe Excel sheet name (max 31 chars, unique)"""
              if not name:
                  name = "Sheet"
          
              # Clean invalid characters for Excel sheet names
              safe_name = re.sub(r'[\\/*\[\]:?]', '_', str(name))
          
              # Truncate to fit within Excel's 31 character limit, leaving room for suffix
              max_base_length = 25  # Leave room for " (999)" suffix
              if len(safe_name) > max_base_length:
                  safe_name = safe_name[:max_base_length]
          
              # Handle duplicates
              final_name = safe_name
              counter = 1
              while final_name in existing_sheets:
                  counter += 1
                  suffix = f" ({counter})"
                  # Ensure total length doesn't exceed 31 characters
                  if len(safe_name) + len(suffix) > 31:
                      truncated = safe_name[:31-len(suffix)]
                      final_name = f"{truncated}{suffix}"
                  else:
                      final_name = f"{safe_name}{suffix}"
          
              return final_name

          # ---------- Enhanced XML parsing ----------
          def extract_functions():
              xml_files = glob.glob('./BlindTreasure.UnitTest/bin/**/*.xml', recursive=True)
              agg = {}  # key=(Class, Func) -> data
          
              print(f"Found {len(xml_files)} XML files")
          
              for f in xml_files:
                  try:
                      root = ET.parse(f).getroot()
                  except Exception as e:
                      print(f"Error parsing {f}: {e}")
                      continue
          
                  for m in root.findall('.//member'):
                      name = m.get('name','')
                      print(f"Processing XML member name: {name}")
                      if not name.startswith('M:'): 
                          print(f"Skipping {name}: Does not start with M:")
                          continue
                      if not name.startswith(XML_PREFIX): 
                          print(f"Skipping {name}: Does not start with XML_PREFIX ({XML_PREFIX})")
                          continue
                      parts = name.split('.')
                      if len(parts) < 2: 
                          print(f"Skipping {name}: Not enough parts after splitting by '.'")
                          continue
                      cls = parts[-2]
                      test_method = strip_params(parts[-1])
                      func = base_function_from_test(test_method)
                      print(f"Extracted: Class={cls}, Test Method={test_method}, Function={func}")

                      # Extract basic information
                      desc = ''
                      scenario = ''
                      expected = ''
                      coverage = ''
          
                      s = m.find('summary')
                      if s is not None and s.text: 
                          desc = ' '.join(s.text.split())
          
                      r = m.find('remarks')
                      remarks_text = ''
                      if r is not None and r.text:
                          remarks_text = r.text
                          for line in remarks_text.splitlines():
                              line = line.strip()
                              if line.startswith('Scenario:'): 
                                  scenario = line.replace('Scenario:','').strip()
                              elif line.startswith('Expected:'): 
                                  expected = line.replace('Expected:','').strip()
                              elif line.startswith('Coverage:'): 
                                  coverage = line.replace('Coverage:','').strip()

                      # Store test-specific XML data for matrix generation
                      test_xml_data = {
                          'test_type': extract_xml_tag_value(remarks_text, 'TestType'),
                          'input_conditions': extract_xml_tag_value(remarks_text, 'InputConditions'),
                          'expected_result': extract_xml_tag_value(remarks_text, 'ExpectedResult'),
                          'expected_return_value': extract_xml_tag_value(remarks_text, 'ExpectedReturnValue'),
                          'exception_expected': extract_xml_tag_value(remarks_text, 'ExceptionExpected'),
                          'log_message': extract_xml_tag_value(remarks_text, 'LogMessage'),
                          'remarks_text': remarks_text
                      }

                      key = (cls, func)
                      if key not in agg:
                          agg[key] = {
                              "Class": cls,
                              "Function": func,
                              "Description": desc,
                              "PreCondition": scenario,
                              "Expected": expected,
                              "Requirement": coverage,
                              "test_data": {}  # Store per-test XML data
                          }
                      else:
                          if not agg[key]["Description"] and desc: 
                              agg[key]["Description"] = desc
                          if not agg[key]["PreCondition"] and scenario: 
                              agg[key]["PreCondition"] = scenario
                          if not agg[key]["Expected"] and expected: 
                              agg[key]["Expected"] = expected
                          if not agg[key]["Requirement"] and coverage:  
                              agg[key]["Requirement"] = coverage
          
                      # Store test-specific data
                      agg[key]["test_data"][test_method] = test_xml_data
          
              print(f"Extracted {len(agg)} functions from XML")
              return list(agg.values())

          # ---------- TRX robust parse ----------
          def parse_trx():
              trx_files = glob.glob('./TestResults/**/test-results.trx', recursive=True)
              if not trx_files: 
                  print("No TRX files found")
                  return []
          
              print(f"Parsing TRX file: {trx_files[0]}")
          
              with open(trx_files[0],'r',encoding='utf-8') as f:
                  soup = BeautifulSoup(f.read(),'xml')

              id_map={}
              total_unit_tests = 0
              for ut in soup.find_all('UnitTest'):
                  total_unit_tests += 1
                  ut_id = ut.get('id') or ut.get('testId')
                  tm = ut.find('TestMethod');
                  if not ut_id or tm is None: 
                      print(f"Skipping UnitTest: id={ut_id}, tm_found={tm is not None}")
                      continue
                  class_full = tm.get('className','')
                  method_name = strip_params(tm.get('name',''))
                  id_map[ut_id]=(short_class(class_full), method_name)

              print(f"Total UnitTest elements found: {total_unit_tests}")
              print(f"Found {len(id_map)} test definitions in TRX id_map")

              out=[]
              total_unit_test_results = 0
              for res in soup.find_all('UnitTestResult'):
                  total_unit_test_results += 1
                  tid = res.get('testId')
                  if not tid or tid not in id_map: 
                      print(f"Skipping UnitTestResult: testId={tid}, id_map_contains={tid in id_map}")
                      continue
                  cls, mth = id_map[tid]
                  out.append({
                      "Class": cls,
                      "Method": mth,               # test method name
                      "Base": base_function_from_test(mth),  # function-under-test
                      "Outcome": res.get('outcome','Unknown'),
                      "Display": strip_params(res.get('testName','')),
                      "ExecutedAt": res.get('endTime') or res.get('startTime') or ''
                  })
          
              print(f"Total UnitTestResult elements found: {total_unit_test_results}")
              print(f"Parsed {len(out)} test results from TRX")
              return out

          # ---------- Build "Functions" & "Statistics" ----------
          def build_core():
              funcs = extract_functions()
              trx = parse_trx()
          
              # Debug: Print all test cases
              print("\n=== ALL TEST CASES FROM TRX ===")
              for i, t in enumerate(trx, 1):
                  print(f"{i}. Class: {t['Class']}, Method: {t['Method']}, Base: {t['Base']}")
          
              # Index TRX by (Class, Base)
              idx = defaultdict(list)
              unmatched_tests = []
          # ---------- main ----------
          def main():
            funcs, df_funcs, df_stats, idx = build_core()
            out = "./coveragereport/Functions_Statistics_Report.xlsx"
            
            # Track actual sheet names created (for hyperlink updates)
            sheet_name_mapping = {}
            
            with pd.ExcelWriter(out, engine="xlsxwriter") as w:
              # Core sheets
              df_funcs.to_excel(w, sheet_name="Functions", index=False)
              df_stats.to_excel(w, sheet_name="Statistics", index=False)
              
              wb = w.book
              hdr = wb.add_format({"bold": True,"bg_color":"#1F4E78","font_color":"white","border":1})
              
              for sheet,df in [("Functions",df_funcs),("Statistics",df_stats)]:
                ws = w.sheets[sheet]
                for c,col in enumerate(df.columns):
                  ws.write(0,c,col,hdr)
              
              # Matrix per function
              for f in funcs:
                tests = idx.get((f["Class"], f["Function"]), [])
                if tests:  # Only create matrix if there are tests
                  actual_sheet_name = write_matrix(wb, w, f, tests)
                  sheet_name_mapping[f["Function"]] = actual_sheet_name
              
              # Update hyperlinks in Statistics sheet
              stats_ws = w.sheets["Statistics"]
              for i, f in enumerate(funcs):
                if f["Function"] in sheet_name_mapping:
                  actual_name = sheet_name_mapping[f["Function"]]
                  hyperlink_formula = f'=HYPERLINK("#{actual_name}!A1","Code_{i+1}")'
                  stats_ws.write(i+1, 1, hyperlink_formula)
            
            print(f"Report generated: {out}")
         
             # Final summary with enhanced XML parsing statistics
             total_tests_in_report = sum([row["Total Test Cases"] for _, row in df_stats.iterrows()])
            xml_parsed_tests = 0
            fallback_parsed_tests = 0
            
            for f in funcs:
              tests = idx.get((f["Class"], f["Function"]), [])
              for t in tests:
                test_xml_data = f.get("test_data", {}).get(t["Method"], {})
                if test_xml_data and any(test_xml_data.values()):
                  xml_parsed_tests += 1
                else:
                  fallback_parsed_tests += 1
            
            print(f"\n=== FINAL SUMMARY ===")
            print(f"Total functions: {len(funcs)}")
             print(f"Total test cases in report: {total_tests_in_report}")
             print(f"Tests parsed from XML tags: {xml_parsed_tests}")
             print(f"Tests parsed from method names (fallback): {fallback_parsed_tests}")
             print(f"XML parsing coverage: {(xml_parsed_tests/total_tests_in_report*100):.1f}%" if total_tests_in_report > 0 else "XML parsing coverage: 0%")
          
          if __name__ == "__main__":
            main()
          EOF
          python generate_excel_report.py

      - name: Upload Excel coverage reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: excel-functions-statistics-report
          path: ./coveragereport/Functions_Statistics_Report.xlsx
          retention-days: 30