name: Unit Tests with Excel Report (Functions + Statistics)

on:
  push:
    branches: [devphuctrann]

jobs:
  test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            nuget-${{ runner.os }}-

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
          cache: true
          cache-dependency-path: '**/*.csproj'

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          pip install pandas openpyxl xlsxwriter lxml beautifulsoup4

      - name: Restore dependencies
        run: dotnet restore BlindTreasure.API.sln

      - name: Build with XML docs
        run: |
          dotnet build BlindTreasure.API.sln \
            --no-restore \
            --configuration Release \
            /p:GenerateDocumentationFile=true
          find ./BlindTreaure.UnitTest/bin -name "*.xml" | sort || true

      - name: Run unit tests with coverage
        run: |
          dotnet test BlindTreasure.API.sln \
            --no-build \
            --configuration Release \
            --verbosity normal \
            --collect:"XPlat Code Coverage" \
            --results-directory ./TestResults/ \
            --logger "trx;LogFileName=test-results.trx"
          find ./TestResults -name "test-results.trx" | sort || true

      - name: Generate Excel Report (Functions + Statistics)
        run: |
          mkdir -p coveragereport
          cat > generate_excel_report.py << 'EOF'
          import pandas as pd
          import xml.etree.ElementTree as ET
          from bs4 import BeautifulSoup
          from collections import defaultdict
          import glob, re

          # Chấp nhận cả 2 cách viết (phòng sai chính tả Treasure/Treaure)
          XML_NAMESPACE_PREFIXES = (
              "M:BlindTreaure.UnitTest.Services.",
              "M:BlindTreasure.UnitTest.Services.",
          )

          def short_class(full_class: str) -> str:
              return full_class.split('.')[-1] if full_class else ""

          def strip_params(name: str) -> str:
              return name.split('(')[0] if name else name

          # ---------- XML: lấy Functions (nguồn chuẩn cho sheet Functions) ----------
          def extract_functions_from_xml():
              xml_files = glob.glob('./BlindTreaure.UnitTest/bin/**/*.xml', recursive=True)
              funcs = []
              for f in xml_files:
                  try:
                      tree = ET.parse(f)
                      root = tree.getroot()
                      for m in root.findall('.//member'):
                          name = m.get('name', '')
                          if not name.startswith('M:'):
                              continue
                          if not any(name.startswith(pref) for pref in XML_NAMESPACE_PREFIXES):
                              continue

                          parts = name.split('.')
                          if len(parts) < 2:
                              continue
                          cls = parts[-2]
                          met = parts[-1]
                          method_base = strip_params(met)

                          summary = ""
                          scenario = ""
                          coverage = ""
                          sum_e = m.find('summary')
                          if sum_e is not None and sum_e.text:
                              summary = ' '.join(sum_e.text.split())

                          rem_e = m.find('remarks')
                          if rem_e is not None and rem_e.text:
                              for line in rem_e.text.splitlines():
                                  line = line.strip()
                                  if line.startswith("Scenario:"):
                                      scenario = line.replace("Scenario:", "").strip()
                                  elif line.startswith("Coverage:"):
                                      coverage = line.replace("Coverage:", "").strip()

                          funcs.append({
                              "Class": cls,
                              "Method": method_base,
                              "Description": summary,
                              "PreCondition": scenario,
                              "Requirement": coverage,
                              "Sheet": f"{cls}Management"
                          })
                  except Exception:
                      pass
              return funcs

          # ---------- TRX: lấy kết quả thực tế ----------
          def parse_trx_results(target_classes_short):
              """
              Map UnitTestResult(testId) -> UnitTest(TestMethod class/name) để lấy class & method chuẩn.
              Không lọc theo prefix namespace cứng; chỉ giữ test có class short trùng với Functions.
              """
              trx_files = glob.glob('./TestResults/**/test-results.trx', recursive=True)
              if not trx_files:
                  return []

              with open(trx_files[0], 'r', encoding='utf-8') as f:
                  s = BeautifulSoup(f.read(), 'xml')

              # Map UnitTest id -> (classFull, methodBase)
              id_to_method = {}
              for ut in s.find_all('UnitTest'):
                  ut_id = ut.get('id') or ut.get('testId')
                  tm = ut.find('TestMethod')
                  if not ut_id or tm is None:
                      continue
                  class_full = tm.get('className', '')
                  method_base = strip_params(tm.get('name', ''))
                  cls_short = short_class(class_full)
                  if cls_short in target_classes_short:
                      id_to_method[ut_id] = (class_full, method_base)

              results = []
              for r in s.find_all('UnitTestResult'):
                  test_id = r.get('testId') or r.get('testId')
                  if not test_id or test_id not in id_to_method:
                      continue
                  outcome = r.get('outcome', 'Unknown')
                  display = strip_params(r.get('testName', ''))
                  class_full, method_base = id_to_method[test_id]
                  results.append({
                      "ClassFull": class_full,
                      "Class": short_class(class_full),
                      "Method": method_base,
                      "Outcome": outcome,
                      "Display": display
                  })
              return results

          # ---------- Match method ----------
          def normalize_for_match(s: str) -> str:
              return re.sub(r'[^A-Za-z0-9_]', '', s or '').lower()

          def is_same_function(doc_method: str, trx_method: str) -> bool:
              d = normalize_for_match(doc_method)
              t = normalize_for_match(trx_method)
              if d == t:
                  return True
              # Method_Should..., Method_When...
              if t.startswith(d + 'should') or t.startswith(d + '_should'):
                  return True
              if t.startswith(d + 'when') or t.startswith(d + '_when'):
                  return True
              if t.startswith(d + '_'):
                  return True
              return False

          def classify_case(name: str) -> str:
              n = (name or "").lower()
              if "boundary" in n or "_boundary" in n:
                  return "B"
              if "abnormal" in n or "_abnormal" in n:
                  return "A"
              if "normal" in n or "_normal" in n:
                  return "N"
              return "N"

          # ---------- Build report ----------
          def build_report():
              funcs = extract_functions_from_xml()
              if not funcs:
                  return pd.DataFrame(), pd.DataFrame()

              target_classes_short = { f["Class"] for f in funcs }
              trx = parse_trx_results(target_classes_short)

              # FUNCTIONS
              funcs_rows = []
              for i, f in enumerate(funcs, start=1):
                  funcs_rows.append({
                      "No": i,
                      "RequirementName": f["Requirement"],
                      "Class Name": f["Class"],
                      "Function Name": f["Method"],
                      "Function Code": f"Code_{i}",
                      "Sheet Name": f["Sheet"],
                      "Description": f["Description"],
                      "Pre-Condition": f["PreCondition"]
                  })

              # Index TRX by class short
              class_to_tests = defaultdict(list)
              for t in trx:
                  class_to_tests[t["Class"]].append(t)

              # STATISTICS per function (aggregate all matched tests of that function)
              stats_rows = []
              for i, f in enumerate(funcs, start=1):
                  cls = f["Class"]
                  method = f["Method"]
                  tests = class_to_tests.get(cls, [])

                  passed = failed = untested = 0
                  n_cnt = a_cnt = b_cnt = 0

                  for t in tests:
                      if is_same_function(method, t["Method"]) or is_same_function(method, t["Display"]):
                          if t["Outcome"] == "Passed":
                              passed += 1
                          elif t["Outcome"] == "Failed":
                              failed += 1
                          else:
                              untested += 1
                          case = classify_case(t["Display"] or t["Method"])
                          if case == "N": n_cnt += 1
                          elif case == "A": a_cnt += 1
                          elif case == "B": b_cnt += 1

                  total = passed + failed + untested  # không ép Untested=1 nếu không match
                  stats_rows.append({
                      "No": i,
                      "Function Code": f'=HYPERLINK("#{f["Sheet"]}!A1","Code")',
                      "Passed": passed,
                      "Failed": failed,
                      "Untested": untested,
                      "N": n_cnt,
                      "A": a_cnt,
                      "B": b_cnt,
                      "Total Test Cases": total
                  })

              return pd.DataFrame(funcs_rows), pd.DataFrame(stats_rows)

          def main():
              df_funcs, df_stats = build_report()
              out_file = "./coveragereport/Functions_Statistics_Report.xlsx"
              with pd.ExcelWriter(out_file, engine="xlsxwriter") as w:
                  df_funcs.to_excel(w, sheet_name="Functions", index=False)
                  df_stats.to_excel(w, sheet_name="Statistics", index=False)

                  wb = w.book
                  hdr = wb.add_format({"bold": True, "bg_color": "#4472C4", "font_color": "white", "border": 1})
                  for sheet, df in [("Functions", df_funcs), ("Statistics", df_stats)]:
                      ws = w.sheets[sheet]
                      for c, col in enumerate(df.columns):
                          ws.write(0, c, col, hdr)
              print(out_file)

          if __name__ == "__main__":
              main()
          EOF
          python generate_excel_report.py

      - name: Upload Excel coverage reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: excel-functions-statistics-report
          path: ./coveragereport/Functions_Statistics_Report.xlsx
          retention-days: 30
