name: Unit Tests with Excel Report

on:
  push:
    branches: [ main, devphuctrann ]
  pull_request:
    branches: [ main, devphuctrann ]

jobs:
  test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            nuget-${{ runner.os }}-

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
          cache: true
          cache-dependency-path: '**/*.csproj'

      - name: Setup Python for Excel generation
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          pip install pandas openpyxl xlsxwriter lxml beautifulsoup4

      - name: Restore dependencies
        run: dotnet restore BlindTreasure.API.sln

      - name: Build
        run: dotnet build BlindTreasure.API.sln --no-restore --configuration Release

      - name: Restore tools
        run: dotnet tool restore

      - name: Run unit tests
        run: |
          dotnet test BlindTreasure.API.sln \
            --no-build \
            --configuration Release \
            --verbosity normal \
            --collect:"XPlat Code Coverage" \
            --results-directory ./TestResults/ \
            --logger "trx;LogFileName=test-results.trx"

      - name: Create Excel coverage report
        run: |
          mkdir -p coveragereport
          cat > generate_excel_report.py << 'EOF'
          import pandas as pd
          import json
          import xml.etree.ElementTree as ET
          from datetime import datetime
          import os
          import glob
          import re
          from bs4 import BeautifulSoup
          
          def parse_cobertura_xml():
              xml_files = glob.glob('./TestResults/**/coverage.cobertura.xml', recursive=True)
              if not xml_files:
                  return None
              tree = ET.parse(xml_files[0])
              root = tree.getroot()
              line_rate = float(root.get('line-rate', 0)) * 100
              branch_rate = float(root.get('branch-rate', 0)) * 100
              classes_data = []
              packages = root.findall('.//package')
              for package in packages:
                  package_name = package.get('name', 'Unknown')
                  classes = package.findall('.//class')
                  for cls in classes:
                      class_name = cls.get('name', 'Unknown')
                      filename = cls.get('filename', 'Unknown')
                      class_line_rate = float(cls.get('line-rate', 0)) * 100
                      class_branch_rate = float(cls.get('branch-rate', 0)) * 100
                      lines = cls.findall('.//line')
                      total_lines = len(lines)
                      covered_lines = len([l for l in lines if l.get('hits', '0') != '0'])
                      classes_data.append({
                          'Package': package_name,
                          'Class': class_name,
                          'File': filename,
                          'Line Coverage (%)': round(class_line_rate, 2),
                          'Branch Coverage (%)': round(class_branch_rate, 2),
                          'Total Lines': total_lines,
                          'Covered Lines': covered_lines,
                          'Uncovered Lines': total_lines - covered_lines
                      })
              return {
                  'summary': {
                      'line_coverage': round(line_rate, 2),
                      'branch_coverage': round(branch_rate, 2)
                  },
                  'classes': classes_data
              }
          
          def extract_test_class_name(test_name):
              # TrÃ­ch xuáº¥t tÃªn class tá»« tÃªn test
              # VÃ­ dá»¥: "BlindTreasure.Test.AuthServiceTest.Login_Success" -> "AuthServiceTest"
              parts = test_name.split('.')
              if len(parts) >= 3:
                  # Láº¥y pháº§n tá»­ káº¿ cuá»‘i, thÆ°á»ng lÃ  tÃªn class test
                  class_name = parts[-2]
                  # Chá»‰ láº¥y nhá»¯ng class káº¿t thÃºc báº±ng "Test" hoáº·c "Tests"
                  if class_name.endswith('Test') or class_name.endswith('Tests'):
                      return class_name
              return 'OtherTests'  # Máº·c Ä‘á»‹nh náº¿u khÃ´ng tÃ¬m tháº¥y máº«u phÃ¹ há»£p
          
          def convert_to_management_name(test_class_name):
              # Chuyá»ƒn Ä‘á»•i tÃªn class test thÃ nh tÃªn sheet Management
              # VÃ­ dá»¥: "AuthServiceTest" -> "AuthManagement"
              if test_class_name.endswith('Test'):
                  base_name = test_class_name[:-4]  # Bá» "Test" á»Ÿ cuá»‘i
              elif test_class_name.endswith('Tests'):
                  base_name = test_class_name[:-5]  # Bá» "Tests" á»Ÿ cuá»‘i
              else:
                  base_name = test_class_name
          
              # Loáº¡i bá» "Service" náº¿u cÃ³
              if base_name.endswith('Service'):
                  base_name = base_name[:-7]
          
              return f"{base_name}Management"
          
          def get_test_description(test_method):
              # Táº¡o mÃ´ táº£ tá»« tÃªn phÆ°Æ¡ng thá»©c test
              # VÃ­ dá»¥: "Login_WithValidCredentials_ReturnsSuccess" -> "Login With Valid Credentials Returns Success"
              # Chia cÃ¡c tá»« báº±ng dáº¥u gáº¡ch dÆ°á»›i
              if '_' in test_method:
                  words = test_method.split('_')
                  return ' '.join(words)
          
              # Náº¿u khÃ´ng cÃ³ gáº¡ch dÆ°á»›i, thá»­ chia theo camel case
              words = re.findall(r'[A-Z](?:[a-z]+|[A-Z]*(?=[A-Z]|$))', test_method)
              if words:
                  return ' '.join(words)
          
              return test_method  # Tráº£ vá» nguyÃªn tÃªn náº¿u khÃ´ng thá»ƒ phÃ¢n tÃ­ch
          
          def parse_test_results():
              trx_files = glob.glob('./TestResults/**/test-results.trx', recursive=True)
              test_data_by_class = {}
          
              if trx_files:
                  try:
                      with open(trx_files[0], 'r', encoding='utf-8') as f:
                          content = f.read()
                          soup = BeautifulSoup(content, 'xml')
                      test_results = soup.find_all('UnitTestResult')
          
                      for result in test_results:
                          test_name = result.get('testName', 'Unknown')
                          outcome = result.get('outcome', 'Unknown')
                          duration = result.get('duration', '00:00:00')
          
                          error_info = result.find('ErrorInfo')
                          error_message = ""
                          if error_info:
                              message_elem = error_info.find('Message')
                              if message_elem:
                                  error_message = message_elem.get_text()
          
                          # Láº¥y tÃªn phÆ°Æ¡ng thá»©c test tá»« testName
                          test_method = test_name.split('.')[-1]
          
                          # Láº¥y tÃªn class test vÃ  chuyá»ƒn Ä‘á»•i thÃ nh tÃªn sheet Management
                          test_class = extract_test_class_name(test_name)
                          sheet_name = convert_to_management_name(test_class)
          
                          # Táº¡o mÃ´ táº£ dá»±a trÃªn tÃªn phÆ°Æ¡ng thá»©c test
                          description = get_test_description(test_method)
          
                          # Táº¡o Ä‘á»‘i tÆ°á»£ng test case vá»›i thÃ´ng tin chi tiáº¿t
                          test_case = {
                              'ID': f"TC_{len(test_data_by_class.get(sheet_name, [])) + 1:03d}",
                              'Test Method': test_method,
                              'Description': description,
                              'Expected Result': 'Pass',
                              'Actual Result': outcome,
                              'Status': 'âœ… Pass' if outcome == 'Passed' else 'âŒ Fail',
                              'Duration': duration,
                              'Error Message': error_message
                          }
          
                          # ThÃªm test case vÃ o danh sÃ¡ch cá»§a class tÆ°Æ¡ng á»©ng
                          if sheet_name not in test_data_by_class:
                              test_data_by_class[sheet_name] = []
          
                          test_data_by_class[sheet_name].append(test_case)
          
                  except Exception as e:
                      print(f"Error parsing TRX file: {e}")
          
              return test_data_by_class
          
          def create_excel_report():
              coverage_data = parse_cobertura_xml()
              test_data_by_class = parse_test_results()
              timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
              excel_file = f'./coveragereport/Coverage_Report_{timestamp}.xlsx'
          
              with pd.ExcelWriter(excel_file, engine='xlsxwriter') as writer:
                  workbook = writer.book
          
                  # Äá»‹nh dáº¡ng cho cÃ¡c header vÃ  cell
                  header_format = workbook.add_format({
                      'bold': True,
                      'text_wrap': True,
                      'valign': 'top',
                      'fg_color': '#4472C4',
                      'font_color': 'white',
                      'border': 1
                  })
          
                  cell_format = workbook.add_format({
                      'text_wrap': True,
                      'valign': 'top',
                      'border': 1
                  })
          
                  pass_format = workbook.add_format({
                      'text_wrap': True,
                      'valign': 'top',
                      'border': 1,
                      'bg_color': '#E2EFDA'  # MÃ u xanh nháº¡t cho Pass
                  })
          
                  fail_format = workbook.add_format({
                      'text_wrap': True,
                      'valign': 'top',
                      'border': 1,
                      'bg_color': '#FFE6E6'  # MÃ u Ä‘á» nháº¡t cho Fail
                  })
          
                  # Táº¡o sheet Summary
                  summary_data = []
                  if coverage_data:
                      total_tests = sum(len(tests) for tests in test_data_by_class.values())
                      passed_tests = sum(len([t for t in tests if t['Status'] == 'âœ… Pass']) for tests in test_data_by_class.values())
          
                      summary_data = [
                          ['Metric', 'Value', 'Status'],
                          ['Line Coverage', f"{coverage_data['summary']['line_coverage']}%", 
                           'âœ… Pass' if coverage_data['summary']['line_coverage'] >= 70 else 'âŒ Fail'],
                          ['Branch Coverage', f"{coverage_data['summary']['branch_coverage']}%", ''],
                          ['Total Tests', total_tests, ''],
                          ['Passed Tests', passed_tests, ''],
                          ['Failed Tests', total_tests - passed_tests, ''],
                          ['Test Pass Rate', f"{(passed_tests / total_tests * 100) if total_tests > 0 else 0:.2f}%", ''],
                          ['Test Run Date', datetime.now().strftime("%Y-%m-%d %H:%M:%S"), ''],
                          ['Minimum Coverage Threshold', '70%', ''],
                      ]
                  else:
                      summary_data = [
                          ['Metric', 'Value', 'Status'],
                          ['Line Coverage', 'N/A', 'No data available'],
                      ]
          
                  df_summary = pd.DataFrame(summary_data[1:], columns=summary_data[0])
                  df_summary.to_excel(writer, sheet_name='Summary', index=False)
                  worksheet_summary = writer.sheets['Summary']
                  worksheet_summary.set_column('A:A', 25)
                  worksheet_summary.set_column('B:B', 20)
                  worksheet_summary.set_column('C:C', 15)
          
                  for row_num in range(len(df_summary) + 1):
                      for col_num in range(len(df_summary.columns)):
                          if row_num == 0:
                              worksheet_summary.write(row_num, col_num, df_summary.columns[col_num], header_format)
                          else:
                              worksheet_summary.write(row_num, col_num, df_summary.iloc[row_num-1, col_num], cell_format)
          
                  # Táº¡o sheet Coverage Details
                  if coverage_data and coverage_data['classes']:
                      df_classes = pd.DataFrame(coverage_data['classes'])
                      df_classes.to_excel(writer, sheet_name='Coverage Details', index=False)
                      worksheet_details = writer.sheets['Coverage Details']
                      worksheet_details.set_column('A:A', 25)
                      worksheet_details.set_column('B:B', 30)
                      worksheet_details.set_column('C:C', 40)
                      worksheet_details.set_column('D:D', 18)
                      worksheet_details.set_column('E:E', 18)
                      worksheet_details.set_column('F:F', 12)
                      worksheet_details.set_column('G:G', 15)
                      worksheet_details.set_column('H:H', 15)
          
                      for row_num in range(len(df_classes) + 1):
                          for col_num in range(len(df_classes.columns)):
                              if row_num == 0:
                                  worksheet_details.write(row_num, col_num, df_classes.columns[col_num], header_format)
                              else:
                                  worksheet_details.write(row_num, col_num, df_classes.iloc[row_num-1, col_num], cell_format)
          
                  # Táº¡o cÃ¡c sheet cho tá»«ng class test (Ä‘Ã£ chuyá»ƒn thÃ nh Management)
                  for sheet_name, test_cases in test_data_by_class.items():
                      # Giá»›i háº¡n tÃªn sheet theo quy táº¯c Excel (tá»‘i Ä‘a 31 kÃ½ tá»±)
                      if len(sheet_name) > 31:
                          sheet_name = sheet_name[:28] + "..."
          
                      df_tests = pd.DataFrame(test_cases)
                      df_tests.to_excel(writer, sheet_name=sheet_name, index=False)
          
                      worksheet = writer.sheets[sheet_name]
                      worksheet.set_column('A:A', 10)  # ID
                      worksheet.set_column('B:B', 35)  # Test Method
                      worksheet.set_column('C:C', 40)  # Description
                      worksheet.set_column('D:D', 20)  # Expected Result
                      worksheet.set_column('E:E', 20)  # Actual Result
                      worksheet.set_column('F:F', 15)  # Status
                      worksheet.set_column('G:G', 15)  # Duration
                      worksheet.set_column('H:H', 50)  # Error Message
          
                      for row_num in range(len(df_tests) + 1):
                          for col_num in range(len(df_tests.columns)):
                              if row_num == 0:
                                  worksheet.write(row_num, col_num, df_tests.columns[col_num], header_format)
                              else:
                                  cell_value = df_tests.iloc[row_num-1, col_num]
          
                                  # Ãp dá»¥ng Ä‘á»‹nh dáº¡ng khÃ¡c nhau dá»±a trÃªn káº¿t quáº£ test
                                  if col_num == 5:  # Status column
                                      if 'âœ… Pass' in str(cell_value):
                                          worksheet.write(row_num, col_num, cell_value, pass_format)
                                      else:
                                          worksheet.write(row_num, col_num, cell_value, fail_format)
                                  else:
                                      worksheet.write(row_num, col_num, cell_value, cell_format)
          
              print(f"âœ… Excel report generated: {excel_file}")
              return excel_file
          
          if __name__ == "__main__":
              excel_file = create_excel_report()
          EOF
          python generate_excel_report.py

      - name: Display coverage summary
        run: |
          echo "## ðŸ“Š Code Coverage Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“Š **Excel Report Available**: Download the detailed Excel report from artifacts below" >> $GITHUB_STEP_SUMMARY

      - name: Upload Excel coverage reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: excel-coverage-report
          path: ./coveragereport/Coverage_Report_*.xlsx
          retention-days: 30